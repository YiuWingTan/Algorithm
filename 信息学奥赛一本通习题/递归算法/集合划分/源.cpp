/*
设S是一个具有n个元素的集合，S＝｛a1，a2，……，an｝，现将S划分成k个满足下列条件的子集合S1，S2，……，Sk ，且满足：



	则称S1，S2，……，Sk是集合S的一个划分。它相当于把S集合中的n个元素a1 ，a2，……，an 放入k个（0＜k≤n＜30）无标号的盒子中，使得没有一个盒子为空。请你确定n个元素a1 ，a2 ，……，an 放入k个无标号盒子中去的划分数S(n，k)。
【输入样例】setsub.in
	23  7
【输出样例】setsub.out
	4382641999117305


	【算法分析】
	先举个例子，设S＝｛1，2，3，4｝，k＝3，不难得出S有6种不同的划分方案，即划分数S(4，3)=6，具体方案为：
｛1，2｝∪｛3｝∪｛4｝  ｛1，3｝∪｛2｝∪｛4｝    ｛1，4｝∪｛2｝∪｛3｝
｛2，3｝∪｛1｝∪｛4｝  ｛2，4｝∪｛1｝∪｛3｝    ｛3，4｝∪｛1｝∪｛2｝
	考虑一般情况，对于任意的含有n个元素a1 ，a2，……，an的集合S，放入k个无标号的盒子中去，划分数为S(n，k)，我们很难凭直觉和经验计算划分数和枚举划分的所有方案，必须归纳出问题的本质。其实对于任一个元素an，则必然出现以下两种情况：
	1、｛an｝是k个子集中的一个，于是我们只要把a1，a2，……，an-1 划分为k－1子集，便解决了本题，这种情况下的划分数共有S(n－1，k－1)个；
	2、｛an｝不是k个子集中的一个，则an必与其它的元素构成一个子集。则问题相当于先把a1，a2，……，an-1 划分成k个子集，这种情况下划分数共有S(n－1，k)个；然后再把元素an加入到k个子集中的任一个中去，共有k种加入方式，这样对于an的每一种加入方式，都可以使集合划分为k个子集，因此根据乘法原理，划分数共有k * S(n－1，k)个。


		 综合上述两种情况，应用加法原理，得出n个元素的集合｛a1，a2，……，an｝划分为k个子集的划分数为以下递归公式：S(n，k)＝S(n－1，k－1) + k * S(n－1，k) (n>k，k>0)。
   下面，我们来确定S(n，k)的边界条件,首先不能把n个元素不放进任何一个集合中去，即k=0时，S(n，k)＝0；也不可能在不允许空盒的情况下把n个元素放进多于n的k个集合中去，即k＞n时,S(n，k)＝0；再者，把n个元素放进一个集合或把n个元素放进n个集合，方案数显然都是1，即k=1或k=n时，S(n,k)=1。
	因此，我们可以得出划分数S(n，k)的递归关系式为：
	S(n，k)＝S(n－1，k－1) + k * S(n－1，k)      (n>k，k>0)
	S(n，k)＝0                         (n<k)或(k＝0)
	S(n，k)＝1                         (k=1)或(k＝n)
*/



#include<iostream>

using namespace std;

long long f(int n, int k)
{

	if (n < k) return 0;

	if (n == k || k == 1) return 1;


	return k*f(n-1,k) + f(n-1,k-1);
}


int main()
{


	int n, k;
	cin >> n >> k;

	cout << f(n,k)<<endl;

	//system("pause");
	return 0;
}
