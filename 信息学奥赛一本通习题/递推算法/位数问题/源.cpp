/*
【问题描述】       在所有的 N位数中，有多少个数中有偶数个数字3？由于结果可能很大，你只需要输出这个答案对12345取余的值。
【输入格式】
读入一个数N
【输出格式】
输出有多少个数中有偶数个数字3。
【输入样例】
2
【输出样例】
73
【数据规模】
1<=N<=1000
【样例说明】
在所有的2位数字，包含0个3的数有72个，包含2个3的数有1个，共73个


【算法分析】
方法一：排列组合(但需要运用动态规划)。
可以列出公式,在n个格子中放x个3(其中x为偶数,包括0).。
c(n,x)*9^(n-x)-c(n-1,x)*9^(n-x-1) 含义为在n个格子中取x个3,且不考虑第一位的特殊情况为c(n,x)*9^(n-x)。
而第一位为0的情况,为c(n-1,x)*9^(n-x-1),两者减下,就为答案。
方法二：递推
考虑这种题目,一般来说都是从第i-1位推导第i位,且当前位是取偶数还是取奇数的。
恍然大悟.可以用f[i][0]表示前i位取偶数个3有几种情况,f[i][1]表示前i位取奇数个3有几种情况。
则状态转移方程可以表示为:
　　　f[i][0]=f[i-1][0]*9+f[i-1][1];f[i][1]=f[i-1][0]+f[i-1][1]*9;这里的9表示不考虑最后一位的情况，在非最后一位的时候是9，最后一位的时候是8
   边界条件:f[1][1]=1;f[1][0]=9;


*/

#include<iostream>
#include<vector>

using namespace std;


long long a[10001][2];

int main()
{


	int n;
	int x = 9;
	cin >> n;

	a[1][0] = 9; a[1][1] = 1;
	

	for (int i = 2; i <= n; i++)
	{
		if (i == n) x--;

		a[i][0] = (a[i - 1][1] + a[i - 1][0] * x)%12345;
		a[i][1] = (a[i - 1][1] * x + a[i - 1][0]) % 12345;
	}

	cout << a[n][0] << endl;

	return 0;
}