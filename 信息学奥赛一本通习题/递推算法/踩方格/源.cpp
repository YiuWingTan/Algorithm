
/*
【题目描述】
有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：

a、每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；

b、走过的格子立即塌陷无法再走第二次；

c、只能向北、东、西三个方向走；

请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。

【输入】
允许在方格上行走的步数n(n≤20)。

【输出】
计算出的方案数量。

【输入样例】
2【输出样例】
7


【算法分析】

首先思考该题的时候不能使用类似于广度优先的算法来进行思考因为方格的走法并不是一直向外的有可能先向外后向里(这也是一种走法)
我们使用三个数组，r,l,u。
l[i]表示最后一步向左走到达第i个格，那么它上一格不能是从右边走得到，
r[i]表示最后一步向右走到达第i个格，那么它上一格不能是从左边走得到，
u[i]表示最后一步先上走到达第i个格；
对于第n个格子有可能n-1往上走，或者是n-1往右走，或者是n-1往左走。

*/


#include<iostream>
using namespace std;

long long r[21],l[21],u[21];

int main()
{
	int n;
	cin >> n;

	u[1] = l[1] = r[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		l[i] = l[i-1]+u[i-1];
		r[i] = r[i-1] + u[i-1];
		u[i] = l[i-1]+r[i-1] + u[i-1];
	}

	cout << (l[n] + r[n] + u[n]) << endl;

	return 0;
}



